---
title: Initialisation de la gestion forestière, scénario BAU
subtitle: Parc naturel régional du Massif des Bauges
author: "Raphaël Aussenac, Jean-Matthieu MONNET, Patrick Vallet"
date: "6 octobre 2020"
output:
  html_document:
    self_contained: TRUE
    number_sections: true
    toc: true
    toc_depth: 2
  pdf_document:
    number_sections: true
    fig_caption: yes
  word_document: default
urlcolor: blue
---

```{r setup, include=FALSE}
rm(list=ls())
library(knitr)
knitr::opts_chunk$set(echo = TRUE, fig.width=12, fig.height=8)
# library(kableExtra)
#library(rgl)
#knit_hooks$set(webgl = hook_webgl)
options(scipen=999)
# wkhtmltopdf -B 15 -L 15 -R 15 -T 15 fiche-observatoire.html fiche-observatoire.pdf
```

---
# Introduction {-}

La procédure précédente (cf document 13ab_Initialisation_biophys.Rmd) a permis de découper les forêts du PNR du Massif des Bauges en un ensemble de polygones, et de leur affecter des caractéristiques forestières initiales (composition, dendrométrie) ainsi qu'un indice de fertilité. La procédure qui suit vise à leur attribuer des itinéraires de gestion sylvicole, et à préparer les fichiers d'entrée qui permettront au module CAPSIS SIMMEM de simuler l'évolution de ces peuplements, selon le scénario "BAU".

Plusieurs variables sont jugées importantes pour déterminer si les peuplements sont gérés, et le cas échéant, quel itinéaire sylvicole leur est appliqué :

* la propriété (publique / privé)
- la taille moyenne des parcelles cadastrales
- les conditions d'accessibilité.

Les étapes suivantes sont réalisées pour affecter un itinéraire sylvicole à chaque polygone :

* extraction des variables pour chaque polygone
- modélisation de la probabilité de gestion / non-gestion
- affectation d'un itinéraire.

```{r charge.donnees.peuplement, echo=FALSE, warning=FALSE, message=FALSE}
# load full file
forestStands <- read.table("./output/forestStandsFULL.txt", header=TRUE, sep = '\t')
forestStands$`WKT-GEOM` <- as.character(forestStands$`WKT.GEOM`)
forestStands <- sf::st_sf(forestStands[,-which(names(forestStands)=="WKT-GEOM")], geom=sf::st_as_sfc(forestStands$`WKT-GEOM`))
sf::st_crs(forestStands) <- 2154
```

Les cartes des polygones présentées ensuite sont basées sur les polygones subsistant à la fin de l'ensemble du processus d'initialisation. Une minorité d'entre eux est enlevée en cours de traitement car il n'est pas possible de leur affecter les valeurs nécessaires aux simulations.

# Extraction des variables

L'extraction est réalisée par le script "03c_extract_anthr.R".

## Propriété et parcellaire

### Superficie des parcelles cadastrales

La couche de la taille de la parcelle est obtenue à partir de la couche vecteur BD PARCELLAIRE v1.2. La surface de chaque parcelle est calculée. Puis ces valeurs de surface sont rasterisées au pas de 5 m. La superficie moyenne des parcelles cadastrales est calculée comme la moyenne des pixels contenus pour chaque polygone. Comme les polygones découpés pour la simulation ne s'alignent pas parfaitement avec les parcelles cadastrales, des effets de bordures peuvent être constatés lorsque de petites parcelles jouxtent une très grande parcelle.

```{r carte.taille.parcelle, echo=FALSE, warning=FALSE, message=FALSE}
par(mfrow=c(1,1))
plot(forestStands["surface"], border=NA, main="Surface cadastrale moyenne (ha)", logz=TRUE)
```

### Public et privé

La couche des forêts publiques est rasterisée au pas de 5 m. Les forêts hors de cette emprise sont considérées comme étant des forêts privées. Chaque polygone est affecté à la catégorie public ou privé selon la valeur majoritaire des pixels qu'il contient.

```{r carte.propriete, echo=FALSE, warning=FALSE, message=FALSE}
par(mfrow=c(1,1))
levels(forestStands$DOMAINE_TYPE) <- ifelse(levels(forestStands$DOMAINE_TYPE)=="Priv", "Privé", "Public")
plot(forestStands["DOMAINE_TYPE"], border=NA, main="Propriété",col=ifelse(forestStands$DOMAINE_TYPE=="Privé", "green","blue"))
legend("topright", c("Privé", "Public"), fill=c("green", "blue"))
```

## Accessibilité

Le modèle Sylvaccess est utilisé sur le territoire du PNR pour cartographier les zones bûcheronnables et celles accessibles aux engins forestiers (cf. livrable 1.3A). Dans la suite du document, on désigne par non-bûcheronnables les zones où l'on considère que la pente (supérieure à 110%) rend l'accessibilité à pied difficile et le bûcheronnage impossible. On désigne par non accessible les zones auxquelles les engins forestiers de débardage ne peuvent pas accéder d'après le modèle Sylvaccess.

Un polygone est considéré comme non-bûcheronnable si il contient au minimum 35,15% de pixels classés non-bûcheronnable. Ce seuil est choisi car il permet de conserver la surface totale non-bûcheronnable sur l'ensemble du territoire. Les pixels non-bûcheronnables formant rarement de grands ensembles contigus, l'utilisation d'un seuil à 50% conduirait à une surface totale des polygones classés "non-bûcheronnables" inférieure à la surface totale des pixels classés "non-bûcheronnables".

Pour la même raison de conservation des surfaces entre la carte raster et la carte des polygones, un polygone est considéré comme non accessible aux engins si le nombre de pixels non accessibles est supérieur à 0,85 fois le nombre de pixels accessibles.

Pour les polygones accessibles, la distance moyenne de débardage est égale à la moyenne des distances des pixels accessibles.

```{r carte.accessibilite, echo=FALSE, warning=FALSE, message=FALSE}
par(mfrow=c(1,2))
plot(forestStands["gestion"], border=NA, main="Accessibilité", col=ifelse(forestStands$gestion=="NonAcc", "pink", ifelse(forestStands$gestion=="NonBuch", "purple", ifelse(forestStands$dist>=2000, "yellow", "green" ))))
legend("topright", c("Accessible <2km", "Accessible >2km", "Non accessible", "Non bûcheronnable"), fill=c("green", "yellow", "pink", "purple"))
# plot(forestStands["dist"], border=NA, main="Distance forêt-route (m), polygones <2km")
```

## Nettoyage des polygones

Le nombre de polygones est 26675, pour 52585 ha. Le nettoyage est effectué de manière séquentielle.

4 polygones n'ont pas d'information de propriété. Ils totalisent 26 m^2^, ils sont supprimés.

18 des polygones restants n'ont pas de taille moyenne de parcelle cadastrale. Ils sont situés le long de l'Isère et totalisent 17 ha. Ils sont supprimés.

Le nombre final de polygones est de 26653, pour 52568 ha.

# Gestion / non-gestion

Cette étape est réalisée par le script "03d_model_anthr.R", qui s'occupe également de l'affectation des itinéraires, ainsi que de la mise au format SIMMEM.

## Modélisation de la probabilité de gestion

Dans le cadre du projet OUI-GEF, une enquête a été mise en oeuvre par Mihai Tivadar (UR LESSEM, INRAE Grenoble) sur les conditions influençant la gestion des parcelles. Sur le massif des Bauges, 311 parcelles ont été enquêtées. On s'intéresse notamment à la réponse à la question : "avez-vous réalisé une opération de gestion sur votre parcelle ?". Plusieurs choix étaient proposés, la réponse a été convertie en réponse binaire oui/non. Pour chaque parcelle enquêtée sont extraites les variables suivantes, de la même manière que pour les polygones :

* surface cadastrale $surface$,
- distance moyenne de débardage $dist$.

Un modèle linéaire généralisé avec une loi binomiale est utilisé pour modéliser la probabilité de gestion en fonction de deux variables : le logarithme de $surface$ et la variable $(dist - 1000) \times (dist < 2000)$ qui tient compte de l'effet de la distance de débardage pour les distances inférieures à 2000 m.

Ce modèle est ensuite appliqué aux polygones en propriété privée pour estimer la probabilité de gestion. Pour les polygones en forêt publique, on définit arbitrairement la probabilité de gestion comme étant de 1 pour une distance de débardage de 0 m, et décroissant linéairement à 0,8 pour une distance de débardage de 2000 m.

Les polygones avec une distance de débardage supérieure à 2000 m, ou se trouvant en zone non débardable ou non bûcheronnable sont affectés d'une probabilité de gestion de 0.


```{r modele.gestion, echo=FALSE, warning=FALSE, message=FALSE}
par(mfrow=c(1,2))
plot(forestStands$dist, forestStands$proba, col=forestStands$DOMAINE_TYPE, xlab="Distance (m)", ylab="Probabilité de gestion", cex=0.5, main="Probabilité de gestion estimée")
legend("topright", c("Public","Privé"), fill=c("red", "black"))
plot(log(forestStands$surface), forestStands$proba, col=forestStands$DOMAINE_TYPE, xlab="Logarithme de la surface cadastrale moyenne (ha)", ylab="Probabilité de gestion", cex=0.5, main="Probabilité de gestion estimée")
```

## Choix gestion / non-gestion

Un tirage au sort est ensuite effectué selon un loi uniforme entre 0 et 1 pour déterminer si une parcelle est gérée (valeur inférieure à la probabilité modélisée) ou non. Les parcelles non bûcheronnables ou situées à plus de 2 km d'une route forestière sont donc systématiquement non-gérés, pour les autres cela dépend de la surface moyenne des parcelles cadastrales qu'ils contiennent (pour les forêts privées), ou de la distance à la route forestière. Les résultats sont présentés sur les figures suivantes.

```{r carte.gestion, echo=FALSE, warning=FALSE, message=FALSE}
par(mfrow=c(1,2))
plot(forestStands["proba"], border=NA, main="Probabilité de gestion")
levels(forestStands$gestion) <- gsub("AccGere", "Accessible géré", levels(forestStands$gestion))
levels(forestStands$gestion) <- gsub("AccNonGere", "Accessible non géré", levels(forestStands$gestion))
levels(forestStands$gestion) <- gsub("NonAcc", "Non accessible", levels(forestStands$gestion))
levels(forestStands$gestion) <- gsub("NonBuch", "Non bûcheronnable", levels(forestStands$gestion))
plot(forestStands["gestion"], border=NA, main="Gestion", col=ifelse(forestStands$gestion=="Non bûcheronnable", "purple", ifelse(forestStands$gestion=="Non accessible", "pink", ifelse(forestStands$gestion=="Accessible géré", "blue", "red"))))
legend("topright", c("Accessible géré", "Accessible non géré", "Non accessible", "Non bûcheronnable"), fill=c("blue", "red", "pink", "purple"))
```



# Affectation des itinéraires sylvicoles

Afin de limiter la quantité de paramétrage à effectuer pour les itinéraires, il a été choisi de limiter à la fois le nombre d'itinéraires sylvicoles, et le nombre de catégories de peuplements.

## Typologie des peuplements

On considère que les itinéraires appliqués vont dépendre de la propriété (public / privé) et de la composition en essence. Une typologie des peuplements selon ces deux critères est donc proposée :

* sapin et/ou épicéa en public
- sapin et/ou épicéa en privé
- mixte public : hêtre et (sapin ou épicéa) en public
- mixte privé : hêtre et (sapin ou épicéa) en privé
- hêtre pur
- autres feuillus

```{r typologie, echo=FALSE, warning=FALSE, message=FALSE}
# gestion et type de peuplements
# par(mfrow=c(1,2))
tab.typo.gestion <- as.data.frame.matrix(questionr::wtd.table(forestStands$typologie, forestStands$gestion, weights = forestStands$AREA/10000, digits=0))
tab.typo.gestion <- as.matrix(t(tab.typo.gestion))
#
tab.typo <- apply(tab.typo.gestion, 2, sum)
pie(tab.typo, col=c("red", "orange", "green", "cyan", "darkgreen", "blue"), labels=paste(names(tab.typo), round(tab.typo/sum(tab.typo)*100, 1)))
plot(forestStands["typologie"], border=NA, key.pos=NULL, pal=c("red", "orange", "green", "cyan", "darkgreen", "blue"), main="Typologie des polygones")
```

La répartition des types de peuplement selon la gestion (ou non) est présentée dans les figures ci-dessous.

```{r gestion.typo, echo=FALSE, warning=FALSE, message=FALSE}
# gestion et type de peuplements
tab.typo.gestion <- as.data.frame.matrix(questionr::wtd.table(forestStands$typologie, forestStands$gestion, weights = forestStands$AREA/10000, digits=0))
tab.typo.gestion <- as.matrix(t(tab.typo.gestion))
#
# tab.typo <- apply(tab.typo.gestion, 2, sum)
#
par(mar=c(7,4,2,2))
par(mfrow=c(1,2))
barplot(tab.typo.gestion, col=c("blue", "red", "pink", "purple"), las=2, cex.names=0.8, main="Surface (ha)")
# legend("topright", c("Accessible géré", "Accessible non géré", "Non débardable", "Non bûcheronnable"), fill=c("green", "blue", "pink", "purple"), cex=0.7)
barplot(apply(tab.typo.gestion, 2, function(x){x/sum(x)*100}), width=apply(tab.typo.gestion, 2, sum), col=c("blue", "red", "pink", "purple"), las=2, cex.names=0.8, main="Pourcentage")
```

Pour chaque polygone, la valeur de RDI est calculée pour chaque espèce du mélange (le cas échéant) et pour l'ensemble du peuplement. Sur la base du RDI et du diamètre quadratique moyen du polygone, une probabilité d'être un peuplement irrégulier est calculée (script code1.R)

## Typologie des itinéraires

Les itinéraires proposés et leur implémentation dans le simulateur sont décrits ci-dessous :

* Amélioration puis coupe rase : les sous-itinéraires sont caractérisés par des plages de RDI autorisées de 0,6 $\pm$ 0,05 et 0,7 $\pm$ 0,05. L'éclaircie se fait plutôt parmi les arbres les plus petits (Kg=0,9). L'ensemble du peuplement est coupé quand le diamètre objectif est atteint (résineux 50 cm et hêtre 40 cm en pur résineux public ou mixte public, 40 cm pour toutes les essences en pur résineux privé,  mixte privé et en hêtre pur privé et public).
- Coupe rase : la coupe est déclenchée uniquement quand le diamètre dominant objectif est atteint (sapin et épicéa : 40cm ; hêtre et autres feuillus : 30 cm). Le RDI est maintenu au-dessous de 1 par mortalité.
- Irrégulier : les trois sous-itinéraires sont caractérisés par des plages de RDI autorisées de 0,5 $\pm$ 0,1 (clair), 0,7 $\pm$ 0,1 (moyen) et 0,9 $\pm$ 0,1 (dense). L'éclaircie se fait plutôt parmi les arbres les plus gros (Kg=1,5 par défaut), de manière permanente car le diamètre objectif fixé (200) est impossible à atteindre.
- Inaction : la mortalité s'applique pour maintenir le RDI au-dessous de 1.

Dans le cas de peuplements mélangés, le comportement par défaut du simulateur est de tendre vers l'équilibre des deux espèces.

##  Répartition des itinéraires

Chaque scénario se caractérise par une matrice de répartition de chaque catégorie de peuplement dans les différents itinéraires. Tout d'abord les polygones non-bûcheronnables sont placés en "Inaction". Pour les polygones bûcheronnables, un tableau de répartition a été proposé par FCBA sur la base de l'analyse des structures des placettes PROTEST et IFN (ces placettes étant jugés représentatives des peuplements qu'il est possible d'atteindre).

### Affectaction des polygones bûcheronnables aux itinéraires

Pour chaque catégorie de polygones, les étapes successives pour l'affectaction des polygones bucheronnables aux itinéraires sont (script "src/sc1_BAU.R" contenant les proportions, et qui appelle des fonctions définies dans "src/management.R") :

* Les polygones considérés comme non-gérés sont placés en "Inaction". Si le pourcentage de polygones placés en "Inaction" est supérieur au pourcentage indiqué dans la matrice, alors le pourcentage des autres itinéraires est modifié par réduction en proportion de leurs valeurs respectives. Sinon des peuplements tirés au sort sont affectés en "Inaction" jusqu'à que le pourcentage indiqué dans la matrice soit atteint.
- Parmi les polygones restants, des polygones sont affectés à l'itinéraires "Irrégulier" jusqu'à atteindre le pourcentage indiqué, par tirage au sort prenant en compte la probabilité des polygones d'être des peuplements irréguliers.
- Parmi les polygones restants, des polygones sont affectés par tirage au sort à l'itinéraire "Coupe Rase" jusqu'à atteindre le pourcentage indiqué.
- Parmi les polygones restants, des polygones sont affectés par tirage au sort à l'itinéraire "Amélioration puis coupe Rase" jusqu'à atteindre le pourcentage indiqué (en théorie il s'agit de tous les polygones restants).

La répartition finale des itinéraires est la suivante:
```{r itineraire, echo=FALSE, warning=FALSE, message=FALSE}
# itineraire
forestStands$itineraire <- factor(ifelse(substr(forestStands$COMMENT,1,2)=="Co", "Inaction",
                                  ifelse(substr(forestStands$COMMENT,1,2)=="Ir", "Irrégulier",
                                         ifelse(substr(forestStands$COMMENT,1,2)=="Th", "Amélioration","Coupe rase"))))
# gestion et type de peuplements
tab.typo.itineraire <- as.data.frame.matrix(questionr::wtd.table(forestStands$typologie, forestStands$itineraire, weights = forestStands$AREA/10000, digits=0))
tab.typo.itineraire <- as.matrix(t(tab.typo.itineraire))
tab.typo.itineraire <- tab.typo.itineraire[c(2,1,4,3),]
#
tab.itineraire <- apply(tab.typo.itineraire, 1, sum)
pie(tab.itineraire, col=c("red", "orange", "yellow", "darkgrey"), labels=paste(names(tab.itineraire), round(tab.itineraire/sum(tab.itineraire)*100, 1)), main="Pourcentage des itinéraires")
plot(forestStands["itineraire"], pal=c("orange", "red", "darkgrey", "yellow"), border=NA, key.pos=1)
```

```{r itineraire.typo, echo=FALSE, warning=FALSE, message=FALSE}
par(mar=c(7,4,2,2))
par(mfrow=c(1,2))
barplot(tab.typo.itineraire, col=c("red", "orange", "yellow", "darkgrey"), las=2, cex.names = 0.8, main="Surface (ha)")
# legend("topright", row.names(tab.typo.itineraire), fill=c("orange", "red", "darkgrey", "yellow"))
barplot(apply(tab.typo.itineraire, 2, function(x){x/sum(x)*100}), width=apply(tab.typo.itineraire, 2, sum), col=c("red", "orange", "yellow", "darkgrey"), las=2, cex.names = 0.8, main="Pourcentage")
```

### Affectation aux sous-itinéraires

Afin de limiter les coupes initiales de rattrapage lorsque des peuplements avec un fort RDI sont affectés à un itinéraire autorisant des plages de RDI plus faibles, des sous-itinéraires sont proposés pour les itinéraires "Irrégulier" et "Amélioration puis coupe rase" (script code2.R). Étant donné qu'un peuplement avec un RDI et un Dg moyen "pousse" d'environ 0,047 RDI sur un intervalle de 3 ans, un polygone est affecté par défaut au sous-itinéraire vérifiant RDI_inf + 0.05 <= RDI_polygone < RDI_sup + 0.05. Les polygones avec des RDI hors de ces plages sont affectés, pour les RDI inférieurs (resp. supérieurs) au sous-itinéraire avec l'intervalle le plus bas (resp. le plus élevé).

Les croix bleues sur les graphiques de Dg correspondent à la valeur de diamètre dominant (moyenne des 100 plus gros diamètres par hectare) qui va déclencher la coupe finale. Le scénario irrégulier est simulé comme un système permanent d'éclaircie, en fixant un diamètre objectif impossible à atteindre quand les éclaircies sont réalisées en prélevant préférentiellement les arbres les plus gros du peuplement.

```{r rdi, echo=FALSE, warning=FALSE, message=FALSE}
# État initial des peuplements
# summary(forestStands[,-26])
# hist(forestStands$RDI)
# boxplot(RDI~gestion, data=forestStands, las=2)
# boxplot(RDI~COMMENT, data=forestStands)
#
# test <- aggregate(AREA~COMMENT, data)
for (i in levels(forestStands$itineraire))
{
  par(mar=c(9.5,4,2,2))
  par(mfrow=c(1,2))
  par(las=2)
  dummy <- forestStands[forestStands$itineraire==i,]
  dummy$COMMENT <- factor(dummy$COMMENT)
  levels(dummy$COMMENT) <- substr(levels(dummy$COMMENT), ifelse(is.element(i, c("Inaction", "Coupe rase")), 4, 3), 100)
  levels(dummy$COMMENT) <- gsub("bfs","Mixte", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("fsp","Sapin-épicéa", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("oak","Chêne", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("bee","Hêtre", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("Pu","_Public", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("Pr","_Privé", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("PP","", levels(dummy$COMMENT))
  test <- aggregate(AREA~COMMENT, data=dummy, FUN=sum)
  boxplot(RDI~COMMENT, data=dummy, xlab="", width=test$AREA, main=paste0("RDI ",i))#, xaxt="n")
  # if (i=="Coupe rase") {abline(h=1.5, col="blue");abline(h=c(1.5-0.05, 1.5+0.05), col="blue", lty=2)}
  # if (i=="Amélioration") {abline(h=c(0.6, 0.7), col="blue");abline(h=c(0.55, 0.65, 0.75), col="blue", lty=2)}
  if (i=="Amélioration")
  {
    segments(x0=0, x1=5.5, y0=c(0.55, 0.6, 0.65), col="blue", lty=c(2,1,2))
    segments(x0=5.5, x1=11, y0=c(0.65, 0.7, 0.75), col="blue", lty=c(2,1,2))
    }
  if (i=="Irrégulier")
  {
    segments(x0=0, x1=5.5, y0=c(0.4, 0.5, 0.6), col="blue", lty=c(2,1,2))
    segments(x0=5.5, x1=11, y0=c(0.6, 0.7, 0.8), col="blue", lty=c(2,1,2))
    segments(x0=11, x1=16.5, y0=c(0.8, 0.9, 1), col="blue", lty=c(2,1,2))
    }
  abline(h=1, col="red", lty=3)
  #
  boxplot(Dgtot~COMMENT, data=dummy, xlab="", width=test$AREA, main=paste0("Dg ",i))#, xaxt="n")
  if (i=="Coupe rase") {points(c(1,2,3), c(30, 40, 30),col="blue", pch=3)}
  if (i=="Amélioration") {points(c(1,2,3,4, 6, 7,8,9, 3,5,8,10), c(rep(40,8), rep(50, 4)),col="blue", pch=3)}
}
```
